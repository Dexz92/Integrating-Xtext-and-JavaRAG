/*
 * generated by Xtext 2.9.2
 */
package se.lth.cs.jastaddxtext.aspect.jvmmodel

import com.google.inject.Inject
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.util.TypeReferences
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor.IPostIndexingInitializing
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import se.lth.cs.jastaddxtext.aspect.aspect.CacheOrUncache
import se.lth.cs.jastaddxtext.aspect.aspect.ClassDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.CollectionContribution
import se.lth.cs.jastaddxtext.aspect.aspect.CollectionDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.Equation
import se.lth.cs.jastaddxtext.aspect.aspect.InheritedDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.InterTypeDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.InterfaceDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.NTAContribution
import se.lth.cs.jastaddxtext.aspect.aspect.Refine
import se.lth.cs.jastaddxtext.aspect.aspect.Rewrite
import se.lth.cs.jastaddxtext.aspect.aspect.SynthesizedDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.AspectDeclaration

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class AspectJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	@Inject extension TypeReferences

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the closure you pass to the returned
	 *            {@link IPostIndexingInitializing#initializeLater(org.eclipse.xtext.xbase.lib.Procedures.Procedure1)
	 *            initializeLater(..)}.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(SynthesizedDeclaration element, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		var String classRefName;
		if (element.classRef != null) {
			classRefName = element.classRef.name
		}
		if(element.isOnASTNode){
			classRefName = "ASTNode"
		}
		acceptor.accept(
			element.toClass("Syn_" + classRefName + "_" + element.name)
		).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation
			if (element.body != null) {
				members += element.toMethod(element.name, inferredType.cloneWithProxies) [
					documentation = element.documentation
					for (p : element.params) {
						parameters += p.toParameter(p.name, p.parameterType)
					}
					body = element.body
					returnType = inferredType.cloneWithProxies
				]
			} else if (element.expr != null) {
				members += element.expr.toMethod(element.name, inferredType.cloneWithProxies) [
					documentation = element.documentation
					for (p : element.params) {
						parameters += p.toParameter(p.name, p.parameterType)
					}
					body = element.expr
					returnType = inferredType.cloneWithProxies
				]
			}
		]
	}

	/**
	 * Dispatch @ InheritedDeclaration
	 */
	def dispatch void infer(InheritedDeclaration element, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		var String classRefName;
		if (element.classRef != null) {
			classRefName = element.classRef.name
		}
		if(element.isOnASTNode){
			classRefName = "ASTNode"
		}
		acceptor.accept(element.toClass("Inh_" + classRefName + "_" + element.name)).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation
		]
	}
	
	/**
	 * Dispatch @ Equation
	 */
	def dispatch void infer(Equation element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		var String className;
		if (element.classRef != null) {
			className = element.classRef.name
		}
		if (element.isOnASTNode) {
			className = "ASTNode"
		}
		acceptor.accept(element.toClass("Eq_" + className + "_" + element.name)).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation
			if (element.body != null) {
				members += element.toMethod(element.name, inferredType.cloneWithProxies) [
					documentation = element.documentation
					for (p : element.params) {
						parameters += p.toParameter(p.name, p.parameterType)
					}
					body = element.body
					returnType = inferredType
					
				]
			} else if (element.expr != null) {
				members += element.expr.toMethod(element.name, inferredType.cloneWithProxies) [
					documentation = element.documentation
					for (p : element.params) {
						parameters += p.toParameter(p.name, p.parameterType)
					}
					body = element.expr
					returnType = inferredType
				]
			}
		]
	}
	
	/**
	 * Dispatch @ CollectionDeclaration
	 */
	def dispatch void infer(CollectionDeclaration element, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		var String classRefName;
		if (element.classRef != null) {
			classRefName = element.classRef.name
		}
		if (element.isOnASTNode) {
			classRefName = "ASTNode"
		}
		acceptor.accept(element.toClass("CollDecl_" + classRefName + "_" + element.name)).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation
			if (element.startExpr != null) {
				members += element.startExpr.toMethod(element.name, inferredType.cloneWithProxies) [
					documentation = element.documentation
					body = element.startExpr
					returnType = inferredType
				]
			}
			if (element.updatingMethod != null) {
				members += element.updatingMethod.toMethod("With_" + element.name, inferredType.cloneWithProxies) [
					documentation = element.documentation
					body = element.updatingMethod
					returnType = inferredType
				]
			}
		]
	}
	
	
	/**
	 * Dispatch @ CollectionContribution
	 */
	def dispatch void infer(CollectionContribution element, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		acceptor.accept(element.toClass("CollContr_" + element.classRef.name + "_" + element.targetName)).
			initializeLater [
				var aspectName = ((element.eContainer) as AspectDeclaration).name
				packageName = aspectName
				documentation = element.documentation
				if (element.valueExp != null) {
					members += element.valueExp.toMethod("When_" + element.targetName, inferredType.cloneWithProxies) [
						documentation = element.documentation
						body = element.valueExp
						returnType = inferredType
					]
				}
				if (element.condExp != null) {
					members += element.condExp.toMethod("To_" + element.targetName, inferredType.cloneWithProxies) [
						documentation = element.documentation
						body = element.condExp
						returnType = inferredType
					]
				}
				if (element.refExp != null) {
					members += element.refExp.toMethod("Ref" + element.targetName, inferredType.cloneWithProxies) [
						documentation = element.documentation
						body = element.refExp
						returnType = inferredType
					]
				}
			]
	}
	
	/**
	 * Dispatch @ NTAContribution
	 */
	def dispatch void infer(NTAContribution element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		var String classRefName;
		if (element.classRef != null) {
			classRefName = element.classRef.name
		}
		if (element.isOnASTNode) {
			classRefName = "ASTNode"
		}
		acceptor.accept(element.toClass("NTAContr_" + classRefName + "_" + element.targetName)).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation
		]
	}
	
	/**
	 * Dispatch @ Refine
	 */
	def dispatch void infer(Refine element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		var String aspectName;
		var String equationName;
		if (element.aspectName != null) {
			aspectName = element.aspectName.name
		}
		if (element.equation != null) {
			equationName = element.equation.name
		}
		acceptor.accept(element.toClass("Refine_" + aspectName + "_" + equationName)).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation
		]
	}
	
	/**
	 * Dispatch @ Rewrite
	 */
	def dispatch void infer(Rewrite element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		var String classRefName;
		if (element.classRef != null) {
			classRefName = element.classRef.name
		}
		if (element.isOnASTNode) {
			classRefName = "ASTNode"
		}
		acceptor.accept(element.toClass("Rewrite_" + classRefName)).initializeLater [
			var aspectName = ((element.eContainer) as AspectDeclaration).name
			packageName = aspectName
			documentation = element.documentation
		]
	}
	
	/**
	 * Dispatch @ CachOrUncache
	 */
	def dispatch void infer(CacheOrUncache element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		var String classRefName;
		if (element.classRef != null) {
			classRefName = element.classRef.name
		}
		if (element.isOnASTNode) {
			classRefName = "ASTNode"
		}
		acceptor.accept(element.toClass(element.cacheType + "_" + classRefName + "_" + element.name)).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation
		]
	}
	
	/**
	 * Dispatch @ InterTypeDeclaration
	 */
	def dispatch void infer(InterTypeDeclaration element, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		var String classRefName;
		if (element.classRef != null) {
			classRefName = element.classRef.name
		}
		if (element.isOnASTNode) {
			classRefName = "ASTNode"
		}
		acceptor.accept(element.toClass("InterType_" + classRefName + "_" + element.name)).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation

			if (element.isIsAbstract) {
				abstract = true
			}
			if (element.body != null) {
				members += element.toMethod(element.name, inferredType.cloneWithProxies) [
					documentation = element.documentation
					for (p : element.params) {
						parameters += p.toParameter(p.name, p.parameterType)
					}
					body = element.body
					returnType = inferredType
				]
			} else if (element.expr != null) {
				members += element.expr.toMethod(element.name, inferredType.cloneWithProxies) [
					documentation = element.documentation
					for (p : element.params) {
						parameters += p.toParameter(p.name, p.parameterType)
					}
					body = element.expr
					returnType = inferredType
				]
			}
		]
	}
	
	/**
	 * Dispatch @ ClassDeclaration
	 */
	def dispatch void infer(ClassDeclaration element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(element.toClass("Class" + "_" + element.name)).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation
			if (element.isAbstract) {
				abstract = true
			}
			members += element.toMethod(element.name, inferredType.cloneWithProxies) [
				documentation = element.documentation
				body = element.body
				returnType = inferredType
			]
		]
	}
	
	/**
	 * Dispatch @ InterfaceDeclaration
	 */
	def dispatch void infer(InterfaceDeclaration element, IJvmDeclaredTypeAcceptor acceptor,
		boolean isPreIndexingPhase) {
		acceptor.accept(element.toClass(element.name)).initializeLater [
			if (element.fullyQualifiedName != null) {
				packageName = element.fullyQualifiedName.firstSegment
			}
			documentation = element.documentation
			interface = true
			members += element.toMethod(element.name, inferredType.cloneWithProxies) [
				documentation = element.documentation
				body = element.body
				returnType = inferredType
			]
		]
	}
}