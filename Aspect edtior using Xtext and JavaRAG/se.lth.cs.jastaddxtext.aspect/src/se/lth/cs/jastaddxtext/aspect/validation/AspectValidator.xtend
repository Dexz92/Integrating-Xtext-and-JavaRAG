/*
 * generated by Xtext 2.9.2
 */
package se.lth.cs.jastaddxtext.aspect.validation

import com.google.inject.Inject
import java.util.List
import java.util.Map
import javarag.impl.reg.BasicAttributeRegister
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver
import se.lth.cs.jastaddxtext.aspect.aspect.AspectDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.AspectPackage
import se.lth.cs.jastaddxtext.aspect.aspect.ClassDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.CollectionDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.Declaration
import se.lth.cs.jastaddxtext.aspect.aspect.DeclarativeDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.Equation
import se.lth.cs.jastaddxtext.aspect.aspect.ImperativeDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.InheritedDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.InterTypeDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.InterfaceDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.Model
import se.lth.cs.jastaddxtext.aspect.aspect.Statement
import se.lth.cs.jastaddxtext.aspect.aspect.SynOrInhDeclaration
import se.lth.cs.jastaddxtext.aspect.aspect.SynthesizedDeclaration
import se.lth.cs.jastaddxtext.aspect.attributes.AspectTreeTraverser
import se.lth.cs.jastaddxtext.aspect.attributes.NameAnalysis
import se.lth.cs.jastaddxtext.javaRAG.ast.ast.Component
import se.lth.cs.jastaddxtext.javaRAG.ast.ast.TokenComponent

/**
 * This class contains custom validation rules. 
 * 
 */
class AspectValidator extends AbstractAspectValidator {

	// Inject used to check the return type of a block
	@Inject extension  IBatchTypeResolver typeResolver

	public static val NAME_LOWERCASE_FIRST_LETTER = "se.lth.cs.jastaddxtext.aspect.validation.NameLowercaseFirstLetter"
	public static val NAME_LOWERCASE_FIRST_LETTER_TEXT = "Name should start with a lowercase letter"

	public static val NAME_UPPERCASE_FIRST_LETTER = "se.lth.cs.jastaddxtext.aspect.validation.ClassUppercaseFirstLetter"
	public static val NAME_UPPERCASE_FIRST_LETTER_TEXT = "Name should start with a uppercase letter"

	public static val INVALID_RETURN_TYPE = "se.lth.cs.jastaddxtext.aspect.validation.ReturnType"

	public static val CIRCULAR_LAZY = "se.lth.cs.jastaddxtext.aspect.validation.UnnecessaryLazy"
	public static val CIRCULAR_LAZY_TEXT = "Circular is always cached, does not need to be defined as lazy"

	public static val MULTIPLE_ASPECTS_WITH_SAME_NAME = "se.lth.cs.jastaddxtext.aspect.validation.DuplicateAspectName"
	public static val MULTIPLE_DECLARATIONS_WITH_SAME_NAME = "se.lth.cs.jastaddxtext.aspect.validation.DuplicateDeclarations"

	public static val ATTRIBUTE_NOT_FOUND_FOR_EQUATION = "se.lth.cs.jastaddxtext.aspect.validation.AttributeNotFoundForEq"
	public static val NO_EQUATION_FOUND_FOR_ATTRIBUTE = "se.lth.cs.jastaddxtext.aspect.validation.MissingEquationForAttribute"
	public static val INH_ATTRIBUTE_HAS_EQUATION_IN_SAME_CLASS = "se.lth.cs.jastaddxtext.aspect.validation.InheritedAttributeWithEquationInSameClass"

	public static val UNNECESSARY_EQUATION = "se.lth.cs.jastaddxtext.aspect.validation.UnnecessaryEquation"

	/*
	 * Retrieves the evaluator for JavaRAG
	 */
	private def getEvaluator(EObject object) {
		val model = EcoreUtil2.getRootContainer(object)
		val registry = new BasicAttributeRegister
		registry.register(NameAnalysis)

		return registry.getEvaluator(model, new AspectTreeTraverser())
	}
	
	/*
	 * Retrieves a List of Declarations from JavaRAG
	 */
	 private def List<Declaration> getJavaRAGDeclList(String name, Statement stmt) {
	 	val evaluator = getEvaluator(stmt)
		return evaluator.evaluate(name, EcoreUtil2.getRootContainer(stmt))
	 }
	 
	 /*
	 * Retrieves a Map from JavaRAG
	 */
	 private def Map<String, Integer> getJavaRAGDeclMap(String name, Statement stmt) {
	 	val evaluator = getEvaluator(stmt)
		return evaluator.evaluate(name, EcoreUtil2.getRootContainer(stmt))
	 }

	/*
	 * Checks if a name starts with a lowercase character
	 */
	private def startsWithLowerCase(String name) {
		if (Character.isUpperCase(name.charAt(0))) {
			warning(
				NAME_LOWERCASE_FIRST_LETTER_TEXT,
				AspectPackage.Literals.DECLARATION__NAME,
				NAME_LOWERCASE_FIRST_LETTER
			)
		}
	}

	/*
	 * Checks if a name starts with a uppercase character
	 */
	private def startsWithUppercase(String name) {
		if (Character.isLowerCase(name.charAt(0))) {
			warning(
				NAME_UPPERCASE_FIRST_LETTER_TEXT,
				AspectPackage.Literals.DECLARATION__NAME,
				NAME_UPPERCASE_FIRST_LETTER
			)
		}
	}

	/**
	 * Checks if the name in a DeclarativeDeclaration starts with a
	 * lowercase character 
	 * 
	 * @Warning name starts with a uppercase character
	 */
	@Check
	def checkDeclarativeStartsWithLowerCase(DeclarativeDeclaration decl) {
		startsWithLowerCase(decl.name)
	}

	/**
	 * Checks if the name in a InterTypeDeclaration starts with a
	 * lowercase character
	 * 
	 * @Warning name starts with a uppercase character
	 */
	@Check
	def checkIntertypeStartsWithLowerCase(InterTypeDeclaration decl) {
		startsWithLowerCase(decl.name)
	}

	/**
	 * Checks if the name in a ClassDeclaration starts with a
	 * uppercase character
	 * 
	 * @Warning name starts with a lowercase character
	 */
	@Check
	def checkClassNameStartsWithUppercase(ClassDeclaration decl) {
		startsWithUppercase(decl.name)
	}

	/**
	 * Checks if the name in a InterfaceDeclaration starts with a
	 * uppercase character
	 * 
	 * @Warning name starts with a lowercase character
	 */
	@Check
	def checkInterfaceNameStartsWithUppercase(InterfaceDeclaration decl) {
		startsWithUppercase(decl.name)
	}
	
	/*
	 * Compares the evaluated return type of an attribute with its declared return type
	 */
	private def correctReturnType(String declaredReturnType, String foundReturnType) {
		if (foundReturnType.equals("null") && !declaredReturnType.equals("void")) {
			error(
				"Missing return statement",
				AspectPackage.Literals.DECLARATION__NAME,
				INVALID_RETURN_TYPE
			)
		} else if (!declaredReturnType.equals(foundReturnType) 
				&& !declaredReturnType.equals("void")
		) {
			error(
				"Type mismatch: cannot convert from " +
					foundReturnType + " to " + declaredReturnType,
				AspectPackage.Literals.DECLARATION__NAME,
				INVALID_RETURN_TYPE
			)
		} else if (declaredReturnType.equals("void") && !foundReturnType.equals("null")) {
			error(
				"Return statement not allowed for void method",
				AspectPackage.Literals.DECLARATION__NAME,
				INVALID_RETURN_TYPE
			)
		}
	}

	/**
	 * Checks that the return type is correct in a SynthesizedDeclaration
	 * 
	 * @Error missing return statement
	 * @Error wrong return type
	 * @Error return statement for void method 
	 */
	@Check
	def checkSynReturnType(SynthesizedDeclaration synDecl) {
		var declaredReturnType = synDecl.type.simpleName
		var foundReturnType = typeResolver.resolveTypes(synDecl).getReturnType(synDecl.body).toString
		correctReturnType(declaredReturnType, foundReturnType)
	}

	/**
	 * Checks that the return type is correct in an InterTypeDeclaration
	 * 
	 * @Error missing return statement
	 * @Error wrong return type
	 * @Error return statement for void method 
	 */
	@Check
	def checkInterTypeReturnType(InterTypeDeclaration interType) {
		var declaredReturnType = interType.type.simpleName
		var foundReturnType = typeResolver.resolveTypes(interType).getReturnType(interType.body).toString
		correctReturnType(declaredReturnType, foundReturnType)
	}

	private def String getEquationDeclaredOnClass(Equation eq) {
		var equationDeclaredOnClass = "ASTNode"
		if (eq.getGetName() != null) {
			for (child : eq.classRef.children) {
				if (child instanceof TokenComponent) {
					if (child.reference == null) {
						equationDeclaredOnClass = child.type.toString
					} else {
						equationDeclaredOnClass = child.reference.name
					}
				} else {
					equationDeclaredOnClass = (child as Component).type.name
				}
			}
		} else if (eq.classRef != null) {
			equationDeclaredOnClass = eq.classRef.name
		}
		
		return equationDeclaredOnClass
	}

	/**
	 * Checks that the return type is correct in an Equation
	 * 
	 * @Error missing return statement
	 * @Error wrong return type
	 * @Error return statement for void method 
	 */
	@Check
	def checkEquationReturnType(Equation eq) {
		val List<Declaration> compareList = getJavaRAGDeclList("attributes", eq)
		var equationAtInit = true
		var String declaredReturnType;
		var String foundReturnType
		var equationDeclaredOnClass = getEquationDeclaredOnClass(eq)

		if (eq.expr == null) {
			foundReturnType = typeResolver.resolveTypes(eq).getReturnType(eq.body).toString
		} else {
			foundReturnType = typeResolver.resolveTypes(eq).getReturnType(eq.expr).toString
		}
		
		// Go through all declared attributes to find a match
		// for the equation
		for (Declaration decl : compareList) {
			if (decl instanceof SynOrInhDeclaration) {
				var attributeDeclaredOnClass = "ASTNode"
				
				if (decl.classRef != null) {
					attributeDeclaredOnClass = decl.classRef.name
				}

				if (equationDeclaredOnClass.equals(attributeDeclaredOnClass)
						&& decl.name.equals(eq.name)
				) {
					declaredReturnType = decl.type.simpleName
					if (decl instanceof SynthesizedDeclaration) {
						if (decl.body == null && decl.expr == null) {
							equationAtInit = false;
						}
					} else {
						equationAtInit = false;
					}
				}	
			}
		}
		
		if (equationAtInit) {
			error(
				"Equation for attribute declared at initialization",
				AspectPackage.Literals.DECLARATION__NAME,
				UNNECESSARY_EQUATION
			)
		} else {
			if (foundReturnType.equals("null")
					&& !declaredReturnType.equals("void")
			) {
				error(
					"Missing return statement",
					AspectPackage.Literals.DECLARATION__NAME,
					INVALID_RETURN_TYPE
				)
			} else if (!foundReturnType.equals(declaredReturnType)
					&& !declaredReturnType.equals("void")
			) {
				error(
					"Type mismatch: cannot convert from " +
						foundReturnType + " to " + declaredReturnType,
					AspectPackage.Literals.DECLARATION__NAME,
					INVALID_RETURN_TYPE
				)
			} else if (declaredReturnType.equals("void")
					&& !foundReturnType.equals("void")
					&& !foundReturnType.equals("null")) {
				error(
					"Return statement not allowed at void function",
					AspectPackage.Literals.DECLARATION__NAME,
					INVALID_RETURN_TYPE
				)
			}
		}
	}
	
	/**
	 * Checks if an equation has a connection to
	 * an attribute
	 * 
	 * @Error no connection to attribute found
	 */
	@Check
	def checkEquationHasConnection(Equation eq) {
		val Map<String, Integer> attributeMap = getJavaRAGDeclMap("attributeDeclMap", eq)
		val attributeName = eq.name;
		var initialized = false
		var String qualifiedName
		var equationDeclaredOnClass = getEquationDeclaredOnClass(eq)
		
		if (!equationDeclaredOnClass.equals("null")) {
			qualifiedName = equationDeclaredOnClass + "." + attributeName
			initialized = true
		}

		if (initialized && !attributeMap.containsKey(qualifiedName)) {
			error(
				"Attribute \"" + attributeName + "\" could not be 
					found in class \"" + equationDeclaredOnClass + "\"",
				AspectPackage.Literals.DECLARATION__NAME,
				ATTRIBUTE_NOT_FOUND_FOR_EQUATION
			)
		}
	}

	/**
	 * Checks if a SynthesizedDeclaration is declared
	 * as both lazy and circular
	 * 
	 * @Warning declared as both lazy and circular 
	 */
	@Check
	def checkCircularAndLazy(SynthesizedDeclaration synDecl) {
		if ((synDecl.circular != null) && synDecl.isLazy) {
			warning(
				CIRCULAR_LAZY_TEXT,
				AspectPackage.Literals.SYN_OR_INH_DECLARATION__LAZY,
				CIRCULAR_LAZY
			)
		}
	}

	/**
	 * Unique name check of AspectDeclarations
	 * 
	 * @Error duplicate declaration
	 */
	@Check
	def checkUnqiueAspectNames(AspectDeclaration decl) {
		var model = (decl.eContainer() as Model)
		var count = 0;
		for (otherDecl : model.aspectElements) {
			if (decl.name.equals(otherDecl.name)) {
				count++;
				if (count > 1) {
					error(
						"Duplicate declaration of aspect \"" + decl.name + "\"",
						AspectPackage.Literals.ASPECT_DECLARATION__NAME,
						MULTIPLE_ASPECTS_WITH_SAME_NAME
					)
				}
			}
		}
	}
	
	 private def String buildQualifiedName(boolean isOnASTNode, String className, String AttributeName) {
	 	var String qualifiedName = null
	 	if (isOnASTNode) {
			qualifiedName = "ASTNode." + AttributeName
		} else if (!className.equals("null")) {
			qualifiedName = className + "." + AttributeName
		}
		return qualifiedName
	 }
	
	/**
	 * Retrieves a qualified name for a DeclarativeDeclaration
	 * 
	 * @returns null if no qualified name can be found
	 */
	private def String getQualifiedName(DeclarativeDeclaration decl) {
		var String className = "null"
		
		if (decl instanceof Equation) {
			if (decl.getGetName != null && decl.getGetName.length > 3) {
				className = decl.getGetName.substring(3);
			}
		} else if (decl.classRef != null) {
			className = decl.classRef.name
		}
		
		return buildQualifiedName(decl.isOnASTNode, className, decl.name)
	}
	
	/**
	 * Retrieves a qualified name for a InterTypeDeclaration
	 * 
	 * @returns null if no qualified name can be found
	 */
	private def String getQualifiedName(InterTypeDeclaration decl) {
		var String className = "null"
		if (decl.classRef != null) {
			className = decl.classRef.name
		}
		
		return buildQualifiedName(decl.isOnASTNode, className, decl.name)
	}
	
	/**
	 * Check SynthesizedDeclaration for a connected equation
	 * 
	 * @Error No equation found the Declaration
	 */
	@Check
	def checkAttributeHasEquation(SynthesizedDeclaration decl) {
		if (decl.body == null && decl.expr == null) {
			val Map<String, Integer> declMap = getJavaRAGDeclMap("equationDeclMap", decl)
			var qualifiedName = getQualifiedName(decl)
			
			// Has the first condition here to prevent false positive in case the qualifiedName
			// is still uninitialized
			if (qualifiedName != null && !declMap.containsKey(qualifiedName)) {
				error(
					"No equation found for synthesized attribute \"" + decl.name + "\"",
					AspectPackage.Literals.DECLARATION__NAME,
					NO_EQUATION_FOUND_FOR_ATTRIBUTE
				)
			}
		}
	}

	/**
	 * Check InheritedDeclaration for a connected equation on itself
	 * 
	 * @Error Forbidden equation declaration
	 */
	@Check
	def checkInhEquationNotOnDeclaredClass(InheritedDeclaration decl) {
		val Map<String, Integer> declMap = getJavaRAGDeclMap("equationDeclMap", decl)
		var String className

		if (decl.isOnASTNode) {
			className = "ASTNode"
		} else {
			className = decl.classRef.name
		}

		var qualifiedName = getQualifiedName(decl)
		if (declMap.containsKey(qualifiedName)) {
			error(
				"The inherited attribute \"" + decl.name + "\" must have its 
					equation in an ancestor to the class \"" +	className + "\"",
				AspectPackage.Literals.DECLARATION__NAME,
				INH_ATTRIBUTE_HAS_EQUATION_IN_SAME_CLASS
			)
		}
	}

	private def uniqueNames(DeclarativeDeclaration decl, String type) {
		val Map<String, Integer> declMap = getJavaRAGDeclMap(type + "DeclMap", decl)
		var qualifiedName = getQualifiedName(decl)

		if (declMap.containsKey(qualifiedName) && declMap.get(qualifiedName) > 1) {
			error(
				"Duplicate declaration of \"" + decl.name + "\"",
				AspectPackage.Literals.DECLARATION__NAME,
				MULTIPLE_DECLARATIONS_WITH_SAME_NAME
			)
		}
	}

	private def uniqueNames(Equation decl) {
		val Map<String, Integer> declMap = getJavaRAGDeclMap("equationDeclMap", decl)
		var className = decl.classRef.name

		if (decl.getGetName != null) {
			if (decl.getGetName.length < 4) {
				className = decl.getGetName
			} else {
				className = decl.getGetName.substring(3);
			}
		}

		var qualifiedName = getQualifiedName(decl)
		if (declMap.containsKey(qualifiedName) && declMap.get(qualifiedName) > 1) {
			error(
				"Duplicate declaration of \"" + decl.name + "\"",
				AspectPackage.Literals.DECLARATION__NAME,
				MULTIPLE_DECLARATIONS_WITH_SAME_NAME
			)
		}
	}

	private def uniqueNames(ImperativeDeclaration decl, String type) {
		val Map<String, Integer> declMap = getJavaRAGDeclMap(type + "DeclMap", decl)
		var qualifiedName = decl.name

		if (decl instanceof InterTypeDeclaration) {
			qualifiedName = getQualifiedName(decl)
		}

		if (declMap.containsKey(qualifiedName) && declMap.get(qualifiedName) > 1) {
			var String typeName;
			if (decl instanceof ClassDeclaration) {
				typeName = "class"
			} else if (decl instanceof InterfaceDeclaration) {
				typeName = "interface"
			} else {
				typeName = ""
			}

			error(
				"Duplicate declaration of " + typeName + " \"" + decl.name + "\"",
				AspectPackage.Literals.DECLARATION__NAME,
				MULTIPLE_DECLARATIONS_WITH_SAME_NAME
			)
		}
	}

	/**
	 * Unique name check of SynOrInhDeclaration
	 * 
	 * @Error duplicate declaration
	 */
	@Check
	def checkUniqueAttributeNames(SynOrInhDeclaration decl) {
		uniqueNames(decl, "attribute")
	}

	/**
	 * Unique name check of InterTypeDeclaration
	 * 
	 * @Error duplicate declaration
	 */
	@Check
	def checkUniqueInterTypeNames(InterTypeDeclaration decl) {
		uniqueNames(decl, "attribute")
	}

	/**
	 * Unique name check of CollectionDeclaration
	 * 
	 * @Error duplicate declaration
	 */
	@Check
	def checkUniqueCollectionDeclarationNames(CollectionDeclaration decl) {
		uniqueNames(decl, "attribute")
	}

	/**
	 * Unique name check of Equation
	 * 
	 * @Error duplicate declaration
	 */
	@Check
	def checkUniqueEquationNames(Equation decl) {
		uniqueNames(decl)
	}

	/**
	 * Unique name check of ClassDeclaration
	 * 
	 * @Error duplicate declaration
	 */
	@Check
	def checkUniqueClassNames(ClassDeclaration decl) {
		uniqueNames(decl, "classAndInterface")
	}

	/**
	 * Unique name check of InterfaceDeclaration
	 * 
	 * @Error duplicate declaration
	 */
	@Check
	def checkUniqueInterfaceNames(InterfaceDeclaration decl) {
		uniqueNames(decl, "classAndInterface")
	}

	/**
	 * Check Equation for correct "get" name of a child node
	 * 
	 * @Error No valid getter found
	 */
	@Check
	def checkEquationHasCorrectGetter(Equation eq) {
		var String classRefGetName
		if (eq?.getGetName().length() > 3
				&& eq.getGetName.substring(0, 3).equals("get")) {
			classRefGetName = eq.getGetName().substring(3)
			var found = false
			if (eq.classRef != null) {
				for (child : eq.classRef.children) {
					var String childName
					if (child instanceof TokenComponent) {
						childName = child.name
					} else {
						childName = (child as Component).name
					}
					if (childName.equals(classRefGetName)) {
						found = true
					}
				}
			}

			if (!found) {
				error(
					"Could not find getter for \"" + classRefGetName +
							"\" in class \"" + eq.classRef.name + "\"",
					AspectPackage.Literals.EQUATION__GET_NAME,
					ATTRIBUTE_NOT_FOUND_FOR_EQUATION
				)
			}
		} else {
			error(
				"Unknown method getter",
				AspectPackage.Literals.EQUATION__GET_NAME,
				ATTRIBUTE_NOT_FOUND_FOR_EQUATION
			)
		}
	}
}