/*
 * generated by Xtext 2.9.0
 */
package se.lth.cs.jastaddxtext.ast.validation

import java.util.HashMap
import java.util.LinkedList
import java.util.List
import java.util.TreeSet
import org.eclipse.xtext.validation.Check
import se.lth.cs.jastaddxtext.ast.ast.AstPackage
import se.lth.cs.jastaddxtext.ast.ast.Child
import se.lth.cs.jastaddxtext.ast.ast.ClassDeclaration
import se.lth.cs.jastaddxtext.ast.ast.Component
import se.lth.cs.jastaddxtext.ast.ast.Model
import se.lth.cs.jastaddxtext.ast.ast.TokenComponent

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AstValidator extends AbstractAstValidator {
	public static val CLASS_NAME_CAPITAL_FIRST_LETTER = "se.lth.cs.jastaddxtext.ast.validation.CapitalFirstLetter"
	public static val CLASS_NAME_CAPITAL_FIRST_LETTER_TEXT = "Class names should start with a capital letter"
	
	public static val MULTIPLE_CLASSES_WITH_SAME_NAME = "se.lth.cs.jastaddxtext.ast.validation.DuplicateClassNames"
	public static val MULTIPLE_CLASSES_WITH_SAME_NAME_TEXT = "Multiple class declarations sharing the same name"
	
	public static val MULTIPLE_CHILDREN_WITH_SAME_NAME = "se.lth.cs.jastaddxtext.ast.validation.DuplicateChildNames"
	public static val MULTIPLE_CHILDREN_WITH_SAME_NAME_TEXT = "Another child with this name has already been declared"
	
	public static val MULTIPLE_CHILDREN_WITH_SAME_TYPE = "se.lth.cs.jastaddxtext.ast.validation.ExplicitChildNamesOnSameType"
	public static val MULTIPLE_CHILDREN_WITH_SAME_TYPE_TEXT = "Multiple children with the same type must have explicit names"

	public static val CLASS_CANNOT_EXTEND_SELF = "se.lth.cs.jastaddxtext.ast.validation.ClassExtendingSelf"
	public static val CLASS_CANNOT_EXTEND_SELF_TEXT = "A class cannot have itself as a superclass"
	
	public static val CHILD_SAME_NAME_AS_PARENT = "se.lth.cs.jastaddxtext.ast.validation.ChildSameNameAsParent"
	public static val CHILD_SAME_NAME_AS_PARENT_TEXT = "Child has same name as its parent class"
	
	public static val CHILD_SAME_TYPE_AS_PARENT = "se.lth.cs.jastaddxtext.ast.validation.ChildSameTypeAsParent"
	public static val CHILD_SAME_TYPE_AS_PARENT_TEXT = "Children cannot be of the same type as their parent"
	
	public static val CHILD_NAME_SAME_AS_TYPE = "se.lth.cs.jastaddxtext.ast.validation.ChildNameSameAsType"
	public static val CHILD_NAME_SAME_AS_TYPE_TEXT = "A childnode's name should not be the same as its type"
	
	public static val CIRCULAR_INHERITANCE = "se.lth.cs.jastaddxtext.ast.validation.CircularInheritance"
	
	public static val REDUNDANT_TOKEN_TYPE = "se.lth.cs.jastaddxtext.ast.validation.RedundantTokenType"
	public static val REDUNDANT_TOKEN_TYPE_TEXT = "String is the default type of a Token"
	
	def childName(Child child) {
		var String tempName
		if (child instanceof TokenComponent) {
			tempName = child.name
		} else {
			tempName = (child as Component).name
		}
		return tempName
	}
	
	def childType(Child child) {
		var String tempType
		if (child instanceof TokenComponent) {
			
			/* If the token isn't a reference, get its type: String or Integer. 
			 * String by default. */
			tempType = child.reference?.name ?: child.type.toString

		} else {
			tempType = (child as Component).type.name
		}
		return tempType
	}
	
	def componentNameHighlight(Child component) {
		if (component instanceof TokenComponent) {
			return AstPackage.Literals::TOKEN_COMPONENT__NAME
		} else {
			return AstPackage.Literals::COMPONENT__NAME
		}
	}
	
		def componentTypeHighlight(Child component) {
		if (component instanceof TokenComponent) {
			return AstPackage.Literals::TOKEN_COMPONENT__TYPE
		} else {
			return AstPackage.Literals::COMPONENT__TYPE
		}
	}

	@Check
	def checkClassStartsWithCapital(ClassDeclaration classDecl){
		if(!Character.isUpperCase(classDecl.name.charAt(0))) {
			warning(
				CLASS_NAME_CAPITAL_FIRST_LETTER_TEXT,
				AstPackage.Literals.CLASS_DECLARATION__NAME,
				CLASS_NAME_CAPITAL_FIRST_LETTER
			)
		}
	}

	@Check
	def checkClassNameIsUnique(ClassDeclaration classDecl) {
		val model = (classDecl.eContainer() as Model)
		var count = 0
		for (other : model.classDeclaration) {
			if (classDecl.getName().equals(other.getName())) {
				count++
				if (count > 1) {
					error(
						MULTIPLE_CLASSES_WITH_SAME_NAME_TEXT,
						AstPackage.Literals::CLASS_DECLARATION__NAME,
						MULTIPLE_CLASSES_WITH_SAME_NAME
					)
				}
			}
		}
	}

	@Check
	def checkUniqueChildNames(ClassDeclaration classDecl) {
		val childNames = new TreeSet<String>()
		var String tempName
		var errorIndex = 0
		for (child : classDecl.children) {
			tempName = childName(child)
			if (tempName != null && !childNames.add(tempName)) {
				error(
					MULTIPLE_CHILDREN_WITH_SAME_NAME_TEXT,
					child, componentNameHighlight(child),
					MULTIPLE_CHILDREN_WITH_SAME_NAME
				)
			}
			errorIndex++
		}
	}

	@Check
	def checkExplicitChildNamesWhenMultipleOfSameType(ClassDeclaration classDecl) {
		val componentsWithoutNames = new HashMap<String, Integer>()
		var String tempType
		var index = 0
		for (child : classDecl.children) {
			tempType = childType(child)
			val noNameOnComponent = childName(child) == null && child instanceof Component
			if (componentsWithoutNames.containsKey(tempType) && noNameOnComponent) {
				error(
					MULTIPLE_CHILDREN_WITH_SAME_TYPE_TEXT,
					child, componentNameHighlight(child),
					MULTIPLE_CHILDREN_WITH_SAME_TYPE
				)
				
				val indexOfFirstError = componentsWithoutNames.get(tempType)
				val firstErrorChild = classDecl.children.get(indexOfFirstError)
				error(
					MULTIPLE_CHILDREN_WITH_SAME_TYPE_TEXT,
					firstErrorChild, componentNameHighlight(firstErrorChild),
					MULTIPLE_CHILDREN_WITH_SAME_TYPE
				)
			} else if(noNameOnComponent) {
				componentsWithoutNames.put(tempType, index)
			}
			index++
		}		
	}
	
	@Check
	def checkClassNotExtendingSelf(ClassDeclaration classDecl) {
		if (classDecl?.superclass.name.equals(classDecl.name)) {
			error(
				CLASS_CANNOT_EXTEND_SELF_TEXT,
				AstPackage.Literals::CLASS_DECLARATION__SUPERCLASS,
				CLASS_CANNOT_EXTEND_SELF
			)
		}
	}
	
	@Check
	def checkChildNameNotSameAsParentName(ClassDeclaration classDecl) {
		var index = 0;
		for (child : classDecl.children) {
			if (childName(child) != null && childName(child).equals(classDecl.name)) {
				warning(
					CHILD_SAME_NAME_AS_PARENT_TEXT,
					child, componentNameHighlight(child),
					CHILD_SAME_NAME_AS_PARENT
				)
			}
			index++
		}
	}
	
	@Check
	def checkChildrenNotOfParentType(ClassDeclaration classDecl) {
		var index = 0;
		for (child : classDecl.children) {
			if (childType(child).equals(classDecl.name)) {
				error(
					CHILD_SAME_TYPE_AS_PARENT_TEXT,
					child, componentTypeHighlight(child),
					CHILD_SAME_TYPE_AS_PARENT
				)
			}
			index++
		}
	}
	
	@Check
	def checkChildNameNotSameAsType(Child child) {
		if (childName(child) != null && childName(child).equals(childType(child))) {
			warning(
				CHILD_NAME_SAME_AS_TYPE_TEXT,
				componentNameHighlight(child),
				CHILD_NAME_SAME_AS_TYPE
			)
		}
	}
	
	@Check
	def checkNonCircularExtension(ClassDeclaration classDecl) {
		if (classDecl.superclass != null) {
			lookForCircularInheritance(classDecl.name, new LinkedList<String>, classDecl.superclass)
		}
	}
	
	def void lookForCircularInheritance(String originClassName,
										List<String> inheritanceList,
										ClassDeclaration classDecl) {
											
		val currentName = classDecl.name
		val superclass = classDecl.superclass
		if (currentName != null && superclass != null) {
			if (!inheritanceList.isEmpty && currentName.equals(originClassName)) {
				val extensionChain = new StringBuilder()
				val nameItr = inheritanceList.iterator
				extensionChain.append(nameItr.next)
				while (nameItr.hasNext) {
					extensionChain.append(" -> " + nameItr.next)
				}

				val message = "Circular inheritance. " + originClassName
									+ " extends (->) the following classes: "
									+ extensionChain.toString + ", and "
									+ inheritanceList.last + " extends " + originClassName
				error(
					message,
					AstPackage.Literals::CLASS_DECLARATION__SUPERCLASS,
					CIRCULAR_INHERITANCE
				)
			} else if (superclass != null
						&& !currentName.equals(originClassName)
						&& !inheritanceList.contains(currentName)) {
				inheritanceList.add(currentName)
				lookForCircularInheritance(originClassName, inheritanceList, superclass)
			}
		}
	}
	
	@Check
	def checkRedundantTokenType(TokenComponent token) {
		/* Needs the first part of the if statement to prevent warning for
		 * a line where an invalid reference is used
		 */
		if (token.reference == null && childType(token).equals("String")) {
			warning(
				REDUNDANT_TOKEN_TYPE_TEXT,
				AstPackage.Literals::TOKEN_COMPONENT__TYPE,
				REDUNDANT_TOKEN_TYPE
			)
		}
	}
}
